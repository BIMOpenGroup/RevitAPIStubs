На данный момент генератор заглушек не очень хорошо работает. Он не позволяет "раскрыть их потенциал".
Но мы можем это исправить вручную в тех местах, где нам это надо.
Например, мы пишем:
```py
import clr
clr.Add
```
и vscode нам показывает список того, как можно дополнить код. Мы понимаем, что заглушка модуля `clr` работает.  
Но бывают случаи, когда нам необходимо вызвать несколько методов подряд, как в `FilteredElementCollector` или когда в цикле получаем какой-то элемент, то vscode перестаёт показывать атрибуты объекта.  
Причина в том, что анализатор `Pylance` не может определить возможный тип рассматриваемого выражения.

`Pylance` постоянно пытается это делать во время того, как вы пишете код. Убедиться в этом очень просто.  
Напишем такую строку `text = "asdf"`. Если навести мышь на переменную `text` и подождать, либо поставить курсор на переменную и нажать `ctrl + k, ctrl + i`, то вы увидите окно с надписью.
```py
text = "asdf"  # (variable) text: Literal['asdf']
```

То же самое работает для переменных цикла:
```py
for text in ['qwer', 'asdf', 'zxcv']:
    print(text)  # (variable) text: str
```

И для функций:
```py
def get_text():
    return 'some_text'

text = get_text()  # (variable) text: Literal['some_text']
```

Из-за того, что у переменной `text` определён тип, нам удобнее с ней работать.

Как я уже писал выше, с заглушками такое не работает, потому что методы классов ничего не возвращают.
А если они ничего не возвращают, то `Pylance` определит переменную как `None`.
Но мы можем это исправить, напишем такой код:
```py
import clr
clr.AddReference("RevitAPI")
from Autodesk.Revit import DB
from rps import doc  # перед запуском надо закомментировать

views = DB.FilteredElementCollector(doc).OfClass(DB.View3D).
```

Vscode не знает, что возвращает метод `OfClass`, поэтому не может предложить следующий метод коллектора.
Исправим код метода, поставив на него курсор, и нажмём F12. Мы окажемся в файле `Autodesk.Revit.DB.__init__.py` на методе `OfClass`.
Документация этого метода говорит нам, что метод должен вернуть экземпляр коллектора `OfClass(self: FilteredElementCollector, type: Type) -> FilteredElementCollector`.  
Поэтому вместо `pass` пишем `return self`. Закрываем модуль-заглушку и ждём некоторое время, чтобы `Pylance` ещё раз проверил все типы.
После этого vscode сможет предложить нам остальные методы коллектора.

Сделаем то же самое для метода `WhereElementIsElementType`. И теперь в переменной `views` будет такой тип:
```py
views = DB.FilteredElementCollector(doc) \
    .OfClass(DB.View3D) \
    .WhereElementIsElementType()  # (variable) views: FilteredElementCollector
```

Используя views дальше в коде, мы можем обращаться к методам коллектора, удобно же.

Но чаще всего мы отправляем коллектор в цикл, и поэтому приходится опять исправлять код заглушки.
```py
# "FilteredElementCollector" is not iterable
# "__iter__" method does not return an objectPylancereportGeneralTypeIssues
for el in views:
    print(el)  # (variable) el: Unknown
```

Первую проблему можно решить изменив `pass` в методе `__iter__` на `return iter()`.  
А вот вторая проблема решается несколькими способами. Все эти способы описаны в модулях-примерах в этой папке, а здесь я опишу то, как это работает.

Уже давно в python существует такое понятие как "подсказки типов" (type hints).
Для python2 и python3 они выглядят немного по-разному.  
В python3 - это часть кода.
```py
number: int = 10
```

В python2 - это комментарий.
```py
number = 10  # type: int
```

В обоих случаях анализатор кода будет понимать, какой тип находится в данной переменной, если до этого не мог определить. Это нужно не только для определения типа, но и для того, чтобы определить ошибку, если в данной переменной изменился тип данных. Это может произойти случайно, из-за чего вы получите проблемы в коде.  
Подробнее о подсказках типов для python2 можно почитать [тут](https://mypy.readthedocs.io/en/stable/cheat_sheet.html).

>Да, Pylance и до этого мог определить, что в number хранится число, но пример специально такой простой, чтобы не содержать ничего лишнего.

Как уже было написано выше, способы решения проблемы
```py
for el in views:
    print(el)  # (variable) el: Unknown
```
смотрите в модулях данной папки.
